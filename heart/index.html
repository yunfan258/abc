<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Three.js 3D祝贺语生成器/心形巧克力</title>
<style>
body {
    font-family: Monospace;
    background-color: #674172;
    margin: 0px;
    overflow: hidden;
    cursor: pointer;
}
.circle {
    background: #c0392b;
    width: 150px;
    height: 150px;
    margin: auto;
    border-radius: 100%;
    overflow: hidden;
    position: absolute;
}
.circle {
    -webkit-animation: grow 5s;
}
@-webkit-keyframes grow {
    0% {
        -webkit-transform: scale(0);
        -moz-transform: scale(0);
        -o-transform: scale(0);
        -ms-transform: scale(0);
        transform: scale(0);
    }
    100% {
        -webkit-transform: scale(1);
        -moz-transform: scale(1);
        -o-transform: scale(1);
        -ms-transform: scale(1);
        transform: scale(1);
    }
}
</style>
</head>
<body>
<script src="js/three.min.js"></script>
<div style="position: absolute;font-size: 20px;color: white;left: 20px;top:15px;text-shadow: 1px 1px 5px rgba(0,0,0,0.5);">
    <strong style="font-size:1.3em;">Generic Compliment Generator, IN 3D!</strong> Mousepress to spawn compliment. Press longer to get BIG heart!
</div>
<div class="circle" style="display:none;"></div>
<script>
"use strict";

var _createClass = (function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var lovequotes = ["我就是喜欢你，怎么样?", 
                  "我希望我是你的镜子.", 
                  "我喜欢你的锁骨.",
                  "你所在的城市，有我的思念因子!", 
                  "我总是意犹未尽的想起你.", 
                  "你非常完美，傻瓜", 
                  "我是粽叶你是米，一层一层裹住你！", 
                  "我是牙齿你是米，香香甜甜黏住你！", 
                  "粽子里有多少米，代表我有多想你！", 
                  "记住必须想着me，不然粽子噎死你！", 
                  "你要是茶叶，我用开水泡着;", 
                  "你要是花儿，我用阳光照着;", 
                  "你要是白云，我用清风托着;",
                  "你要是风筝，我用丝线牵着;",
                  "你是我的最爱，所以我用心装着! ", 
                  "我用天生多情的气场，想要把你细心的捧在手上,", 
                  "请用甜蜜的握住我的手掌，一点一点把我生命点亮,", 
                  "有你我不会再有绝望，是你给我乐观的力量！", 
                  "自从你出现后，我才知道原来有人爱是那么的完美！", 
                  "我知道爱要自由才能欢乐，", 
                  "我却宁愿留在你身边，陪你，陪你走过。", 
                  "我爱你的心是直到世界末日也不变。", 
                  "决定我们一生的，不是我们的本事,而是我们的选择。", 
                  "爱在我这边是鼠标，爱在你那边是屏幕。", 
                  "爱在我那里是邮件，爱在你那里是邮箱。", 
                  "只要我心有所动，你都一一兼容。", 
                  "亲爱的，你知道我爱你吗？", 
                  "你的过去我来不及参与，你的未来我奉陪到底！"];

var colors = ["#ff0000", "#D33257", "#E22211", "#8A2D3C", "#E3000E", "#CF000F", "#BB3658"];

var Heart = (function() {
    function Heart(x, y, s) {
        _classCallCheck(this, Heart);

        this.x = 0;
        this.y = 0;
        this.ShapeX = x;
        this.ShapeY = y;
        this.ShapeZ = 0;
        this.rx = 0;
        this.ry = 0;
        this.rz = Math.PI;
        this.s = s;
        this.Shape = new THREE.Shape();
        this.ExtrudeSettings = {
            amount: 5,
            bevelEnabled: true,
            bevelSegments: 50,
            steps: 50,
            bevelSize: 20,
            bevelThickness: 15
        };
        this.color = colors[Math.floor(Math.random() * colors.length)];
        this.makeShape();
        this.quote = lovequotes[Math.floor(Math.random() * lovequotes.length)];
    }

    _createClass(Heart, [{
        key: "makeShape",
        value: function makeShape() {
            var x = this.x;
            var y = this.y;
            this.Shape.moveTo(x + 25, y + 25);
            this.Shape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y);
            this.Shape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35);
            this.Shape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
            this.Shape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
            this.Shape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y);
            this.Shape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);
        }
    }]);

    return Heart;
})();

var Playground = (function() {
    function Playground() {
        _classCallCheck(this, Playground);

        var self = this;
        var start = 0;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        this.light = new THREE.DirectionalLight(16777215, 0.8);
        this.renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        this.cvs = document.createElement("canvas");
        this.circle = document.getElementsByClassName("circle")[0];
        this.ctx = this.cvs.getContext("2d");
        this.hearts = [];
        this.camera.add(this.light);
        this.camera.position.set(0, 150, 500);
        this.scene.add(this.camera);
        this.setrenderer();
        this.addHeart(0, 100, 1);
        window.requestAnimationFrame(function() {
            self.draw();
        });
        window.addEventListener("resize", function() {
            self.onWindowResize();
        }, false);
        window.addEventListener("mousedown", function(e) {
            start = e.timeStamp;
            self.circle.style.display = "block";
            self.circle.style.left = e.x - 75 + "px";
            self.circle.style.top = e.y - 75 + "px";
        }, false);
        window.addEventListener("mouseup", function(e) {
            self.circle.style.display = "none";
            var size = 0.5 + (e.timeStamp - start) / 3000;
            var vector = new THREE.Vector3();
            vector.set(e.clientX / window.innerWidth * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1, 0.5);
            vector.unproject(self.camera);
            var dir = vector.sub(self.camera.position).normalize();
            var distance = -self.camera.position.z / dir.z;
            var pos = self.camera.position.clone().add(dir.multiplyScalar(distance));
            if (size > 1.7) {
                size = 1.7;
            }
            self.addHeart(pos.x, pos.y, size);
        }, false);
    }

    _createClass(Playground, [{
        key: "onWindowResize",
        value: function onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }, {
        key: "findPos",
        value: function findPos(obj) {
            var curleft = 0,
                curtop = 0;
            if (obj.offsetParent) {
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                return {
                    x: curleft,
                    y: curtop
                };
            }
            return undefined;
        }
    }, {
        key: "addHeart",
        value: function addHeart(x, y, s) {
            var heart = new Heart(0, 0, s);
            var group = new THREE.Group();
            group.position.set(x, y, 0);
            var geometry = new THREE.ExtrudeGeometry(heart.Shape, heart.ExtrudeSettings);
            var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                color: heart.color
            }));
            mesh.position.set(heart.ShapeX, heart.ShapeY, heart.ShapeZ);
            mesh.rotation.set(heart.rx, heart.ry, heart.rz);
            mesh.scale.set(heart.s, heart.s, heart.s);
            group.add(mesh);

            this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);
            this.ctx.font = "20px monaco";
            this.ctx.fillStyle = "#ffffff";
            this.ctx.fillText(heart.quote, 0, 50);
            var tex = new THREE.Texture(this.cvs);
            tex.needsUpdate = true;

            var txtmaterial = new THREE.MeshBasicMaterial({
                map: tex,
                side: THREE.DoubleSide
            });
            txtmaterial.transparent = true;

            var txtmesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(this.cvs.width, this.cvs.height), txtmaterial);
            txtmesh.position.set(heart.ShapeX, heart.ShapeY, 0);
            txtmesh.scale.set(heart.s, heart.s, heart.s);
            group.add(txtmesh);
            this.scene.add(group);
        }
    }, {
        key: "setrenderer",
        value: function setrenderer() {
            this.renderer.setClearColor("#674172");
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(window.innerWidth, window.innerHeight);

            var container = document.createElement("div");
            document.body.appendChild(container);
            container.appendChild(this.renderer.domElement);
        }
    }, {
        key: "draw",
        value: function draw() {
            var self = this;
            this.renderer.render(this.scene, this.camera);
            window.requestAnimationFrame(function() {
                self.draw();
            });
            this.scene.children.forEach(function(e) {
                if (e instanceof THREE.Group) {
                    e.rotation.y += 0.01;
                }
            });
        }
    }]);

    return Playground;
})();

new Playground();
</script>
</body>
</html>